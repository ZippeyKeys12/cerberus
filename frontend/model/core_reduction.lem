open import Pervasives
open import Utils
open import Core Core_aux Core_run_aux

import State
import Core_eval Cmm_aux Cmm_csem

import Cerb_attributes

(* TODO *)
import Core_run

module Cmm = struct
  include Cmm_aux
  include Cmm_csem
end

module Caux = Core_aux
module EU  = Exception_undefined
module SEU = State_exception_undefined

(* TODO: duplicate from Core_run *)
module E = struct
  let inline return = SEU.return
  let inline undef  = SEU.undef
  let inline mapM   = SEU.mapM
  let inline foldlM = SEU.foldM
  
  let fresh_excluded_id =
    SEU.runS (fun run_st ->
    let n = run_st.excluded_supply in
    (n, <| run_st with excluded_supply= n+1 |>)
  )
  
  let eval_pexpr2 th_st core_extern mem_st file pe =
    let current_call_loc_opt =
      match th_st.exec_loc with
        | ELoc_globals ->
            Nothing
        | ELoc_normal [] ->
            Nothing
        | ELoc_normal ((_, loc) :: _) ->
            Just loc
      end
    in
    SEU.runEU (Core_eval.eval_pexpr_aux2 th_st.current_loc current_call_loc_opt core_extern th_st.env (Just mem_st) file pe)
end

let inline (>>=) = SEU.bind
let inline (<$>) = SEU.fmap

let rec full_eval_pexpr th_st core_extern mem_st file pe =
  E.eval_pexpr2 th_st core_extern mem_st file pe >>= (function
    | Left pe' ->
        full_eval_pexpr th_st core_extern mem_st file pe'
    | Right cval ->
        E.return cval
  end)





type action_request2 'a =
  | AllocRequest2 of Symbol.prefix
                  *  Mem.integer_value (* alignment constraint *)
                  *  Mem.integer_value (* size of allocation *)
                  *  (Cmm.aid -> Mem.pointer_value -> 'a) (* new thread state builder *)
  
  | CreateRequest2 of Symbol.prefix
                   *  Mem.integer_value (* alignment constraint *)
                   *  Ctype.ctype (* C type of allocation *)
                   *  maybe integer (* potential requested address (see Cerb_attributes: cerb::with_address()) *)
                   *  maybe Mem.mem_value (* optional initialisation value *)
                   *  (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | StoreRequest2 of Cmm.memory_order (* C11 memory order *)
                  *  Ctype.ctype (* C type of lvalue *)
                  *  bool (* whether the store locks the allocation *)
                  *  Mem.pointer_value
                  *  Mem.mem_value 
                  *  (Cmm.aid -> Mem.footprint -> 'a)
  
  | LoadRequest2 of Cmm.memory_order (* C11 memory order *)
                 *  Ctype.ctype (* C type of lvalue *)
                 *  Mem.pointer_value
              (* *  Symbol.sym  (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *) *)
                 *  (Cmm.aid -> Mem.footprint -> Mem.mem_value -> 'a)
  
  | SeqRMWRequest2 of Ctype.ctype
                   *  Mem.pointer_value
                   *  (Mem.mem_value -> core_runM Mem.mem_value)
                   *  (Cmm.aid -> Mem.footprint -> Mem.mem_value -> Mem.mem_value -> 'a)
  
  (* TODO: RMW, Fence *)
  | KillRequest2 of (* is_dynamic *)bool * Mem.pointer_value * (Cmm.aid -> 'a)


type runstate_step_kind =
  | RSK_eval of string
  | RSK_tau of string * Core_run.core_tau_step_kind

type fs_oper_or_done =
  | FS_done of Core.value
  | FS_oper of Core_run.fs_oper

type core_step2 =
  | Step_ccall2 of Mem_common.thread_id * core_runM thread_state
  | Step_with_runstate2 of runstate_step_kind * core_runM thread_state
  | Step_tau2 of string * Core_run.core_tau_step_kind * thread_state
  
  | Step_action_request2 of string * Loc.t * (* set Cmm.aid * set Cmm.aid * set Cmm.aid * *)
                            Mem_common.thread_id *
                            bool * (* is_unseq_with_ccall *)
                            core_runM (action_request2 thread_state)
  
  | Step_blocked2
  | Step_error2 of string
  | Step_thread_done2 of Mem_common.thread_id * Core.value
  | Step_done2 of Core.value
  | Step_memop_request2 of Loc.t * Mem_common.memop * list Core.value * Mem_common.thread_id * bool(* is_unseq_with_ccall *) * (Core.value -> thread_state)
  | Step_spawn_threads2 of (list Mem_common.thread_id -> thread_state) * list thread_state (* initial states for the children *)
  | Step_fs2 of Mem_common.thread_id * thread_state * core_runM fs_oper_or_done
  | Step_nd2 of list thread_state


instance (Show core_step2)
  let show step =
    match step with
      | Step_ccall2 _ _ ->
          "Step_ccall2"
      | Step_with_runstate2 kind _ ->
          let kind_str =
            match kind with
              | RSK_eval debug_str ->
                  "RSK_eval[" ^ debug_str ^ "]"
              | RSK_tau debug_str kind' ->
                let kind'_str =
                  match kind' with
                    | Core_run.TSK_Ccall sym _ ->
                        "TSK_Ccall(" ^ show sym ^ ")"
                    | Core_run.TSK_Return sym _ ->
                        "TSK_Return(" ^ show sym ^ ")"
                    | Core_run.TSK_Misc ->
                        "TSK_Misc"
                  end in
                "RSK_tau[" ^ debug_str ^ ", " ^ kind'_str ^ "]"
            end in
          "Step_with_runstate2[" ^ kind_str ^ "]"
      | Step_tau2 debug_str kind _ ->
          "Step_tau2<TAU>[" ^ debug_str ^ "]"
      | Step_action_request2 debug_str loc tid is_unseq_with_ccall _ ->
          "Step_action_request2[" ^ debug_str ^ "] -- tid: " ^ show tid ^
          (if is_unseq_with_ccall then " [unseq_with_call]" else "") ^ " -- at loc: " ^ Loc.stringFromLocation loc
      | Step_blocked2 ->
          "Step_blocked2"
      | Step_error2 debug_str ->
          "Step_error2[" ^ debug_str ^ "]"
      | Step_thread_done2 tid cval ->
          "Step_thread_done2(tid: " ^ show tid ^ ") -- value: " ^ Pp.stringFromCore_value cval
      | Step_done2 cval ->
          "Step_done2 -- value: " ^ Pp.stringFromCore_value cval
      | Step_memop_request2 loc memop _ tid is_unseq_with_ccall _ ->
          "Step_memop_request2[" ^ show memop ^ "] -- tid: " ^ show tid ^
          (if is_unseq_with_ccall then " [unseq_with_call]" else "") ^
          " -- at loc: " ^ Loc.stringFromLocation loc
      | Step_spawn_threads2 _ _ ->
          "Step_spawn_threads2"
      | Step_fs2 tid _ _ ->
          "Step_fs2 -- tid: " ^ show tid
      | Step_nd2 _ ->
          "Step_nd2"
    end
end

(* ********************************************************************************************* *)

let is_irreducible = function
    (* annot(..., annot(..., _)) ==> NOTE THE _ may be a value *)
  | Expr _ (Eannot _ (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))))) ->
      (* TODO: this makes the function misnamed, but this has a one step reduction *)
      false
    (* v *)
  | Expr _ (Epure (Pexpr _ _ (PEval _))) ->
      true
    (* annot(..., v) *)
  | Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))) ->
      true
  | _ ->
      false
end


import Debug


val do_race: list Core.dyn_annotation -> list Core.dyn_annotation -> bool
let do_race xs1 xs2 =
  List.any (function
    | DA_neg id1 exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 exclusion2 fp2 ->
              if List.elem id1 exclusion2 || List.elem id2 exclusion1 then
                false
              else
                Mem.overlapping fp1 fp2
          | DA_pos exclusion2 fp2 ->
              if List.elem id1 exclusion2 then
                false
              else
                Mem.overlapping fp1 fp2
        end) xs2
    | DA_pos exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 _ fp2 ->
              if List.elem id2 exclusion1 then
                false
              else
                Mem.overlapping fp1 fp2
          | DA_pos _ fp2 ->
                Mem.overlapping fp1 fp2
        end) xs2
  end) xs1


val combine_dyn_annotations: list Core.dyn_annotation -> list Core.dyn_annotation -> list Core.dyn_annotation
let combine_dyn_annotations xs1 xs2 =
  xs1 ++ xs2


type one_step =
  | TAU_WITH_RUNSTATE of string * core_runM (list (map Symbol.sym value) * Core.expr core_run_annotation)
  | TAU of string * list (map Symbol.sym value) * Core.expr core_run_annotation
  | EVAL of string * core_runM (Core.expr core_run_annotation)
  | ND of list (Core.expr core_run_annotation)
  | MEMOP of Mem_common.memop * list Core.value
  | UNSEQUENCED_RACE
  | ILLTYPED of string


let rec one_step_unseq_aux (fps_acc, cvals_acc) = function
  | [] ->
      Just (fps_acc, List.reverse cvals_acc)
  | Expr _ (Epure (Pexpr _ _ (PEval cval))) :: xs ->
      one_step_unseq_aux (fps_acc, cval::cvals_acc) xs
  | Expr _ (Eannot fps (Expr _ (Epure (Pexpr _ _ (PEval cval))))) :: xs ->
      if do_race fps fps_acc then
        let () = Debug.print_debug 2 [Debug.DB_core_dynamics] (fun () ->
          "FOUND AN UNSEQUENCED RACE: " ^ show fps ^ " <---> " ^ show fps_acc
        ) in
        (* we found an unsequenced race (undefined behaviour) *)
        Nothing
      else
        one_step_unseq_aux (combine_dyn_annotations fps fps_acc, cval :: cvals_acc) xs
  | e :: _ ->
      (* all the operand of the unseq() must have already been reduced to values *)
      error ("Core_reduction.one_step_unseq_aux ==> " ^ Pp.stringFromCore_expr e)
  end


(* Effectless reductions *************************************************************************)
(* NOTE: for performance, we use scoped environment instead of substitutions for bound variables *)
val one_step:
  (Core.pexpr -> core_runM Core.pexpr) ->
  (Core.pexpr -> core_runM Core.value) ->
  list (map Symbol.sym value) -> Core.expr core_run_annotation -> maybe one_step
let one_step eval_pexpr full_eval_pexpr env (Expr annots expr_ as expr) =
  if is_irreducible expr then
    Nothing
  else match expr_ with
    | Epure pe ->
        match valueFromPexpr pe with
          | Just _ ->
              Nothing
          | Nothing ->
              (* reduction: PURE + PURE-UNDEF *)
              Just begin
              (*     eval e = v
                -------------------
                pure(e) --> pure(v) *)
                EVAL "Epure" begin
                  full_eval_pexpr pe >>= fun cval ->
                  E.return (Expr annots (Epure (Caux.mk_value_pe cval)))
                end
              end
      end
    
    | Eannot xs1 (Expr annots2 (Eannot xs2 e)) ->
        (* {A_1} {A_2} E --> {A_1 union A_2} E *)
        (* reduction: ANNOTS *)
        Just (TAU "Eannot" env (Expr (annots ++ annots2) (Eannot (combine_dyn_annotations xs1 xs2) e)))
    
    | Ememop memop pes ->
        Just match valueFromPexprs pes with
          | Just cvals ->
              MEMOP memop cvals
          | Nothing ->
              EVAL "Ememop" begin
                E.mapM eval_pexpr pes >>= fun pes' ->
                E.return (Expr annots (Ememop memop pes'))
              end
        end
    
    | Ecase (Pexpr _ () (PEconstrained xs)) _ ->
        error "TODO: Core_reduction.one_step, Ecase PEconstrained"
    | Ecase pe pat_es ->
        (* reduction: CASE + CASE-UNDEF *)
        Just match valueFromPexpr pe with
          | Just cval ->
              (* TODO: stop using subst? *)
              match select_case subst_sym_expr cval pat_es with
                | Just e' ->
                    TAU "Ecase" env e'
                | Nothing ->
                    ILLTYPED ("Ecase, mismatched ==> " ^ Pp.stringFromCore_expr expr)
              end
          | Nothing ->
              EVAL "Ecase" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (Expr annots (Ecase pe' pat_es))
              end
        end
    
    | Elet pat pe1 e2 ->
        match valueFromPexpr pe1 with
          | Just cval ->
              (* let pat = v in E2 --> { v / pat } E2 *)
              (* reduction: LET(last step) *)
              Just (TAU "Elet" (update_env pat cval env) e2)
          | Nothing ->
              Just begin
              (*              eval e1 = v
                 -------------------------------------
                 let pat = e1 in E2 --> { v / pat } E2 *)
                (* reduction: LET(first step) + LET-UNDEF *)
                TAU_WITH_RUNSTATE "Elet" begin
                  full_eval_pexpr pe1 >>= fun cval ->
                  E.return (update_env pat cval env, e2)
                end
              end
        end
    
    | Eif pe1 e2 e3 ->
        (* reduction: IF-TRUE + IF-FALSE + IF-UNDEF *)
        Just begin
          TAU_WITH_RUNSTATE "Eif" begin
            full_eval_pexpr pe1 >>= function
              | Vtrue ->
                  E.return (env, e2)
              | Vfalse ->
                  E.return (env, e3)
              | _ ->
                  error "TODO(use the core_runM) ILLTYPED, the first operand of an Eif didn't evaluated to a boolean"
            end
          end
        end
    
    | Eunseq es ->
        (* assert: List.all is_irreducible es *)
        match one_step_unseq_aux ([], []) es with
          | Nothing ->
              (* reduction: UNSEQ-RACE *)
              Just UNSEQUENCED_RACE
          | Just (fps, cvals) ->
              (* unseq({A_1}?v1, ..., {A_n}?vn) -->
                 {A_1 ...union... A_n}(v1, ..., v2)    (in the absence of race) *)
              (* reduction: UNSEQ-PURE + UNSEQ-ANNOT *)
              Just (TAU "Eunseq" env (Expr annots (Eannot fps (Caux.mk_value_e (Vtuple cvals)))))
        end
    
    | Ewseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = v in E2 --> { v / pat } E2 *)
              (* reduction: LETW-PURE *)
              TAU "Ewseq" (update_env pat cval env) e2
          | Nothing ->
              error "Core_reduction.one_step Ewseq saw a non-evaluated e1"
        end
    | Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = {A}v in E2 --> {A} { v / pat } E2 *)
              (* reduction: LETW-ANNOT *)
              TAU "Ewseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              error "Core_reduction.one_step Ewseq Eannot saw a non-evaluated e1"
        end
    | Esseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = v in E2 --> { v / pat } E2 *)
              (* reduction: LETS-PURE *)
              TAU "Esseq" (update_env pat cval env) e2
          | Nothing ->
            error "Core_reduction.one_step Esseq saw a non-evaluated e1"
        end
    
    | Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = {A}v in E2 --> {A} { v / pat } E2 *)
              (* reduction: LETS-ANNOT *)
              TAU "Esseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              error "Core_reduction.one_step Esseq Eannot saw a non-evaluated e1"
        end
    
    | Esave sym_bTy sym_bTy_pes e ->
        Just match valueFromPexprs (List.map (fun (_, (_, z)) -> z) sym_bTy_pes) with
          | Just cvals ->
              (* reduction: SAVE (tau part) *)
              TAU "Esave"
                begin
                  List.foldl (fun acc ((sym, ((bTy , _) , _)), cval) ->
                    update_env (Caux.mk_sym_pat sym bTy) cval acc
                 ) env (List.zip sym_bTy_pes cvals)
                end
                e
          | Nothing ->
              (* reduction: SAVE (eval part) + SAVE-UNDEF *)
              EVAL "Esave" begin
                E.mapM (fun (sym, (bTy, pe)) ->
                  eval_pexpr pe >>= fun pe' ->
                  E.return (sym, (bTy, pe'))
                ) sym_bTy_pes >>= fun sym_bTy_pes' ->
                E.return (Expr annots (Esave sym_bTy sym_bTy_pes' e))
              end
        end
    | End es ->
        (* reduction: ND *)
        Just (ND es)

    | _ ->
        Nothing
  end



let rec has_ccall (Expr _ expr_) =
  match expr_ with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eaction _ ->
        false
    | Ecase _ xs ->
        List.any (fun (_, e) ->
          has_ccall e
        ) xs
    | Elet _ _ e ->
        has_ccall e
    | Eif _ e1 e2 ->
        has_ccall e1 || has_ccall e2
    | Eccall _ _ _ _ ->
        true
    | Eproc _ _ _ ->
        false
    | Eunseq es ->
        List.any has_ccall es
    | Ewseq _ e1 e2 ->
        has_ccall e1 || has_ccall e2
    | Esseq _ e1 e2 ->
        has_ccall e1 || has_ccall e2
    | Ebound e ->
        has_ccall e (* NOTE: this function should never see this case (for a C program) *)
    | End es ->
        List.any has_ccall es
    | Esave _ _ e ->
        has_ccall e (* NOTE: this function should never see this case (for a C program) *)
    | Erun _ _ _ ->
        false (* NOTE: this function should never see this case (for a C program) *)
    | Epar _ ->
        false (* because any ccall is in the body of another thread *)
    | Ewait _ ->
        false
    | Eannot _ e ->
        has_ccall e
    | Eexcluded _ _ ->
        false
  end

let rec is_unseq_with_ccall_aux acc = function
  | CTX ->
      acc
  | Cunseq _ es1 ctx' es2 ->
      let acc' = acc || List.any has_ccall (es1 ++ es2) in
      is_unseq_with_ccall_aux acc' ctx'
  | Cwseq _ _ ctx' e2 ->
      is_unseq_with_ccall_aux acc ctx'
  | Csseq _ _ ctx' e2 ->
      is_unseq_with_ccall_aux acc ctx'
  | Cannot _ _ ctx' ->
      is_unseq_with_ccall_aux acc ctx'
  | Cbound _ ctx' ->
      is_unseq_with_ccall_aux false ctx'
end

val is_unseq_with_ccall: Core_run.context -> bool
let is_unseq_with_ccall ctx =
  is_unseq_with_ccall_aux false ctx



val     get_ctx: Core.expr core_run_annotation -> list (context * Core.expr core_run_annotation)
let rec get_ctx (Expr annot expr_ as expr) =
  if is_irreducible expr then
    [(CTX, expr)]
  else match expr_ with
    | Epure _ ->
        [(CTX, expr)]
    | Ememop  _ _ ->
        [(CTX, expr)]
    | Eaction _ ->
        [(CTX, expr)]
    | Ecase _ _ ->
        [(CTX, expr)]
    | Elet _ _ _ ->
        [(CTX, expr)]
    | Eif _ _ _ ->
        [(CTX, expr)]
    | Eccall _ _ _ _ ->
        [(CTX, expr)]
    | Eproc _ _ _ ->
        [(CTX, expr)]
    | Eunseq es ->
        if List.all is_irreducible es then
          [(CTX, expr)]
        else
          get_ctx_unseq_aux annot [] [] es
    | Ewseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cwseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Esseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Csseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Ebound e ->
        if is_irreducible e then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cbound annot ctx, e)
          ) (get_ctx e)
    | End _ ->
        [(CTX, expr)]
    | Esave _ _ _ ->
        [(CTX, expr)]
    | Erun _ _ _ ->
        [(CTX, expr)]
    | Epar _ ->
        [(CTX, expr)]
    | Ewait _ ->
        [(CTX, expr)]
    | Eannot _ (Expr _ (Eannot _ e)) ->
        [(CTX, expr)]
    | Eannot xs e ->
        List.map (fun (ctx, e) ->
          (Cannot annot xs ctx, e)
        ) (get_ctx e)
    | Eexcluded _ _ ->
        [(CTX, expr)]
  end

and get_ctx_unseq_aux annot acc es1 = function
  | [] ->
      acc
  | e :: es2 ->
      if is_irreducible e then
        get_ctx_unseq_aux annot acc (es1 ++ [e]) es2
      else
        let zs =
          List.map (fun (ctx, e) ->
            (Cunseq annot es1 ctx es2, e)
          ) (get_ctx e) in
        get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
end


val     apply_ctx: context -> Core.expr core_run_annotation -> Core.expr core_run_annotation
let rec apply_ctx ctx expr =
  match ctx with
    | CTX ->
        expr
    | Cunseq annot es1 ctx' es2 ->
        Expr annot (Eunseq (es1 ++ (apply_ctx ctx' expr :: es2)))
    | Cwseq annot pat ctx' e2 ->
        Expr annot (Ewseq pat (apply_ctx ctx' expr) e2)
    | Csseq annot pat ctx' e2 ->
        Expr annot (Esseq pat (apply_ctx ctx' expr) e2)
    | Cannot annot xs ctx' ->
        Expr annot (Eannot xs (apply_ctx ctx' expr))
    | Cbound annot ctx' ->
        Expr annot (Ebound (apply_ctx ctx' expr))
  end


let act_valueFromPexpr = function
  | Pexpr _ _ (PEconstrained _) ->
      error "Core_reduction.step_action => PEconstrained"
  | z ->
      valueFromPexpr z
end

type action_step =
  | ACTION_REQUEST of string * Loc.t * action_request2 (Core.expr core_run_annotation)
  | ACTION_EVAL of string * core_runM (Core.action core_run_annotation)
  | ACTION_ILLTYPED of string

val step_action:
    list Annot.annot ->
    (Core.pexpr -> core_runM Core.value) -> maybe nat -> Core.action core_run_annotation -> action_step
let step_action e_annots full_eval_pexpr is_excluded (Action loc act_annots act) =
  let wrap z =
    Action loc act_annots z in
  match act with
    | Create pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty)) ->
              ACTION_REQUEST
                "CreateRequest"
                loc
                begin
                  CreateRequest2 pref ival ty (Cerb_attributes.get_with_address e_annots) Nothing (fun aid ptrval ->
                    Caux.mk_value_e (Vobject (OVpointer ptrval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Create"
          | (_, _) ->
              ACTION_EVAL "eval operands of Create" begin
                full_eval_pexpr pe1 >>= fun cval1 ->
                full_eval_pexpr pe2 >>= fun cval2 ->
                E.return (wrap (Create (Caux.mk_value_pe cval1) (Caux.mk_value_pe cval2) pref))
              end
        end
    | CreateReadOnly pe1 pe2 pe3 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty), Just cval3) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                | Just mval ->
                    ACTION_REQUEST
                      "CreateRequest"
                      loc
                      begin
                        CreateRequest2 pref ival ty (Cerb_attributes.get_with_address e_annots) (Just mval) (fun aid ptrval ->
                          Caux.mk_value_e (Vobject (OVpointer ptrval))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a create_readonly(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval3
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "CreateReadOnly"
          | (_, _, _) ->
              ACTION_EVAL "eval operands of CreateReadOnly" begin
                full_eval_pexpr pe1 >>= fun cval1 ->
                full_eval_pexpr pe2 >>= fun cval2 ->
                full_eval_pexpr pe3 >>= fun cval3 ->
                E.return (wrap (CreateReadOnly (Caux.mk_value_pe cval1) (Caux.mk_value_pe cval2) (Caux.mk_value_pe cval3) pref))
              end
        end
    | Store is_locking pe1 pe2 (Pexpr _ () (PEconstrained xs3)) mo ->
        error "TODO: Core_reduction.step_action => Store pe1 pe2 PEconstrained"
    | Store is_locking pe1 pe2 pe3 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)), Just cval) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval with
                | Just mval ->
                    ACTION_REQUEST
                      "StoreRequest"
                      loc
                      begin
                        StoreRequest2 mo ty is_locking ptrval mval (fun aid fp ->
                          let dyn_annots =
                            match is_excluded with
                              | Nothing ->
                                  [DA_pos [] fp]
                              | Just excl_id ->
                                  [DA_neg excl_id [] fp]
                            end in
                          Expr [] (Eannot dyn_annots (Caux.mk_value_e Vunit))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a store(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "Store"
          | (_, _, _) ->
              ACTION_EVAL "eval operands of Store" begin
                full_eval_pexpr pe1 >>= fun cval1 ->
                full_eval_pexpr pe2 >>= fun cval2 ->
                full_eval_pexpr pe3 >>= fun cval3 ->
                E.return (wrap (Store is_locking (Caux.mk_value_pe cval1) (Caux.mk_value_pe cval2) (Caux.mk_value_pe cval3) mo))
              end
        end
    | Load pe1 pe2 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)))  ->
              ACTION_REQUEST
                "LoadRequest"
                loc
                begin
                  LoadRequest2 mo ty ptrval (fun aid fp mval ->
                    let dyn_annots =
                      match is_excluded with
                        | Nothing ->
                            [DA_pos [] fp]
                        | Just excl_id ->
                            [DA_neg excl_id [] fp]
                      end in
                    let (_, cval) = Caux.valueFromMemValue mval in
                    Expr [] (Eannot dyn_annots (Caux.mk_value_e cval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Load"
          | (_, _) ->
              ACTION_EVAL "eval operands of Load" begin
                full_eval_pexpr pe1 >>= fun cval1 ->
                full_eval_pexpr pe2 >>= fun cval2 ->
                E.return (wrap (Load (Caux.mk_value_pe cval1) (Caux.mk_value_pe cval2) mo))
              end
        end
    | SeqRMW _ _ _ _ _ ->
        error "Core_reduction.step_action ==> SeqRMW" (* this should not be possible *)
    | Alloc pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              ACTION_REQUEST
                "AllocRequest"
                loc
                begin
                  AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                    Caux.mk_value_e (Vobject (OVpointer ptrval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Alloc"
          | (_, _) ->
              ACTION_EVAL "eval operands of Alloc" begin
                full_eval_pexpr pe1 >>= fun cval1 ->
                full_eval_pexpr pe2 >>= fun cval2 ->
                E.return (wrap (Alloc (Caux.mk_value_pe cval1) (Caux.mk_value_pe cval2) pref))
              end
        end
    | Kill kind pe ->
        match act_valueFromPexpr pe with
          | Just (Vobject (OVpointer ptrval)) ->
              ACTION_REQUEST
                "KillRequest"
                loc
                begin
                  KillRequest2 (is_dynamic kind) ptrval
                    (fun aid -> Caux.mk_value_e Vunit)
                end
          | Just _ ->
              ACTION_ILLTYPED "Kill"
          | Nothing ->
              ACTION_EVAL "eval operand of Kill" begin
                full_eval_pexpr pe >>= fun cval ->
                E.return (wrap (Kill kind (Caux.mk_value_pe cval)))
              end
        end
    | RMW _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: RMW"
    | Fence _ ->
        error "TODO[Core_reduction]: Fence"
    | CompareExchangeStrong _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: CompareExchangeStrong"
    | CompareExchangeWeak _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: CompareExchangeWeak"
    | LinuxFence _ ->
        error "TODO[Core_reduction]: LinuxFence"
    | LinuxLoad _ _ _ ->
        error "TODO[Core_reduction]: LinuxLoad"
    | LinuxStore _ _ _ _ ->
        error "TODO[Core_reduction]: LinuxStore"
    | LinuxRMW _ _ _ _ ->
        error "TODO[Core_reduction]: LinuxRMW"
end


val     break_at_sseq: context -> maybe (context * Core.pattern * context * Core.expr core_run_annotation)
let rec break_at_sseq ctx =
  match ctx with
    | CTX ->
        Nothing
    | Cwseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cwseq annots pat ctxA e2, sseq_pat, ctxB, sseq_e2)
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Just (CTX, pat, ctx', e2)
          | Just (in_ctxA, in_pat, in_ctxB, in_e2) ->
              Just (Csseq annots pat in_ctxA e2, in_pat, in_ctxB, in_e2)
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cunseq annots es1 ctxA es2, sseq_pat, ctxB, sseq_e2)
        end
    | Cannot annots xs ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cannot annots xs ctxA, sseq_pat, ctxB, sseq_e2)
        end
    | Cbound annots ctx' ->
        error "break_at_sseq, Cbound"
(*
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cbound annots ctxA, sseq_pat, ctxB, sseq_e2)
        end
*)
  end

type break =
  | NO_BOUND
  | BOUND_NO_SSEQ of context * context
  | BOUND_WITH_SSEQ of context * context * Core.pattern * context * Core.expr core_run_annotation

let rec break_at_bound_and_sseq ctx =
  match ctx with
    | CTX ->
        NO_BOUND
    | Cwseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cwseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cwseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Csseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Csseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cunseq annots es1 ctxA es2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cunseq annots es1 ctxA es2) ctxB sseq_pat ctxC e2_sseq
        end
    | Cannot annots xs ctx' ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cannot annots xs ctxA) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cannot annots xs ctxA) ctxB sseq_pat ctxC e2_sseq
        end
    | Cbound annots ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              BOUND_NO_SSEQ (Cbound annots CTX) ctx'
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              BOUND_WITH_SSEQ (Cbound annots CTX) ctxA sseq_pat ctxB sseq_e2
        end
  end


let rec pull_dyn_annotations z =
  match z with
    | CTX ->
        ([], CTX)
    | Cunseq annots es1 ctx es2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cunseq annots es1 ctx' es2)
    | Cwseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cwseq annots pat ctx' e2)
    | Csseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Csseq annots pat ctx' e2)
    | Cannot annots xs ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (xs :: acc, ctx')
    | Cbound annots ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cbound annots ctx')
  end

let rec add_exclusion n = function
  | CTX ->
      CTX
  | Cunseq annots es1 ctx' es2 ->
      Cunseq annots es1 (add_exclusion n ctx') es2
  | Cwseq annots pat ctx' e2 ->
      Cwseq annots pat (add_exclusion n ctx') e2
  | Csseq annots pat ctx' e2 ->
      Csseq annots pat (add_exclusion n ctx') e2
  | Cannot annots xs ctx' ->
      let xs' = List.map (function
        | DA_neg id excl fp ->
            DA_neg id (n::excl) fp
        | DA_pos excl fp ->
            DA_pos (n::excl) fp
      end) xs in
      Cannot annots xs' (add_exclusion n ctx')
  | Cbound annots ctx' ->
      Cbound annots (add_exclusion n ctx')
end


import Core_reduction_aux

let process_impl_proc full_eval_pexpr wrap_proc wrap_expr th_st iCst pes =
  let forceIntegerFromIntegerValue errmsg ival =
    match Mem_aux.integerFromIntegerValue ival with
      | Just n -> n
      | Nothing -> error errmsg
    end in
  match iCst with
    (* ----------------------------------------------------------- *)
    (* Cerberus headers <any.h> *)
    (* ----------------------------------------------------------- *)
    | Implementation.BuiltinFunction "any_bounded_int" ->
        error "TODO Core_reduction ==> any_bounded_int()"
    (* ----------------------------------------------------------- *)
    (* 7.5 Errors <errno.h> *)
    (* ----------------------------------------------------------- *)
    | Implementation.BuiltinFunction "errno" ->
        match pes with
          | [] ->
              Step_tau2 "errno" Core_run.TSK_Misc (
                wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_value_pe (Vobject (OVpointer th_st.errno)))))
              )
          | _ ->
              error "wrong arguments for __builtin_errno"
        end
    (* ----------------------------------------------------------- *)
    (* 7.22 General utilities <stdlib.h> *)
    (* ----------------------------------------------------------- *)
    | Implementation.BuiltinFunction "exit" ->
        (* TODO: it should close all open resources *)
        match pes with
          | [pe] ->
              match valueFromPexpr pe with
                | Just cval ->
                    Step_done2 cval
                | Nothing ->
                    Step_with_runstate2 (RSK_eval "Eproc exit") begin
                      full_eval_pexpr pe >>= fun cval ->
                      E.return (wrap_proc [Caux.mk_value_pe cval])
                    end
              end
          | _ ->
              error ("Core_reduction, exit given more than one argument ==> " ^ stringFromList Pp.stringFromCore_pexpr pes)
        end
    (* NOTE: some GCC builtins *)
    | Implementation.BuiltinFunction "generic_ffs" ->
        Step_with_runstate2 (RSK_tau "Eproc builtin_generic_ffs" Core_run.TSK_Misc) begin
          match pes with
            | [pe] ->
                full_eval_pexpr pe >>= function
                  | Vobject (OVinteger n_ival) ->
                      let n' = Builtins.gcc_builtin_generic_ffs (forceIntegerFromIntegerValue "generic_ffs" n_ival) in
                      E.return (wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe n'))))
                  | _ ->
                      error "TODO: generic_ffs illtyped"
                end
            | _ ->
                error "TODO: generic_ffs wrong number of args"
          end
        end
    | Implementation.BuiltinFunction "ctz" ->
        Step_with_runstate2 (RSK_tau "Eproc __builtin_ctz" Core_run.TSK_Misc) begin
          match pes with
            | [pe] ->
                full_eval_pexpr pe >>= function
                  | Vobject (OVinteger n_ival) ->
                      let n' = Builtins.gcc_builtin_ctz (forceIntegerFromIntegerValue "ctz" n_ival) in
                      E.return (wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe n'))))
                  | _ ->
                      error "TODO: ctz illtyped"
                end
            | _ ->
                error "TODO: ctz wrong number of args"
          end
        end
    (* TODO: factorise ... *)
    | Implementation.BuiltinFunction "bswap16" ->
        Step_with_runstate2 (RSK_tau "Eproc __builtin_bswap16" Core_run.TSK_Misc) begin
          match pes with
            | [pe] ->
                full_eval_pexpr pe >>= function
                  | Vobject (OVinteger n_ival) ->
                      let n' = Builtins.gcc_builtin_bswap16 (forceIntegerFromIntegerValue "bswap16" n_ival) in
                      E.return (wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe n'))))
                  | _ ->
                      error "TODO: bswap16 illtyped"
                end
            | _ ->
                error "TODO: bswap16 wrong number of args"
          end
        end
    | Implementation.BuiltinFunction "bswap32" ->
        Step_with_runstate2 (RSK_tau "Eproc __builtin_bswap32" Core_run.TSK_Misc) begin
          match pes with
            | [pe] ->
                full_eval_pexpr pe >>= function
                  | Vobject (OVinteger n_ival) ->
                      let n' = Builtins.gcc_builtin_bswap32 (forceIntegerFromIntegerValue "bswap32" n_ival) in
                      E.return (wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe n'))))
                  | _ ->
                      error "TODO: bswap32 illtyped"
                end
            | _ ->
                error "TODO: bswap32 wrong number of args"
          end
        end
    | Implementation.BuiltinFunction "bswap64" ->
        Step_with_runstate2 (RSK_tau "Eproc __builtin_bswap64" Core_run.TSK_Misc) begin
          match pes with
            | [pe] ->
                full_eval_pexpr pe >>= function
                  | Vobject (OVinteger n_ival) ->
                      let n' = Builtins.gcc_builtin_bswap64 (forceIntegerFromIntegerValue "bswap64" n_ival) in
                      E.return (wrap_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe n'))))
                  | _ ->
                      error "TODO: bswap64 illtyped"
                end
            | _ ->
                error "TODO: bswap64 wrong number of args"
          end
        end
    | _ ->
        error "Core_reduction.process_impl_proc ==> TODO"
  end

val step_ctx:
  Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Symbol.sym ->
  Mem_common.thread_id -> (maybe Mem_common.thread_id * thread_state) ->
  list core_step2
let step_ctx mem_st file core_extern current_tid (parent_tid_opt, th_st) =
  let eval_pexpr pe =
    E.eval_pexpr2 th_st core_extern mem_st file pe >>= function
      | Left pe' ->
          E.return pe'
      | Right cval ->
          E.return (Caux.mk_value_pe cval)
    end in
  let full_eval_pexpr' pe =
    full_eval_pexpr th_st core_extern mem_st file pe in
  List.map (function
    | (CTX, Expr e_annots (Epure (Pexpr _ _ (PEval cval)))) ->
        match th_st.stack with
          | Stack_empty ->
              (* reached the end of the execution of a thread. *)
              match parent_tid_opt with
                | Just parent_tid ->
                    (* reduction: THREAD-DONE *)
                    Step_thread_done2 parent_tid cval
                | Nothing ->
                    (* this was the startup thread *)
                    (* reduction: PROGRAM-DONE *)
                    Step_done2 cval
              end
          | Stack_cons2 parent_proc_opt caller_ctx sk' ->
              (* reached the end of the execution of a procedure. *)
              let tsk =
                match th_st.current_proc_opt with
                  | Just psym ->
                      match Map.lookup psym file.funinfo with
                        | Just (_, _, ret_ty, _, _, _) ->
                            Core_run.TSK_Return psym (Core_aux.memValueFromValue ret_ty cval)
                        | Nothing ->
                            Core_run.TSK_Misc
                      end
                  | Nothing ->
                      Core_run.TSK_Misc
                end in
              (* reduction: RETURN *)
              Step_tau2 "end of procedure" tsk begin
                match th_st.env with
                  | [] ->
                      error "end of proc, found an empty Core_run env"
                  | _ :: env' ->
                      <| th_st with
                        arena= apply_ctx caller_ctx (Expr e_annots (Epure (Caux.mk_value_pe cval)));
                        stack= sk';
                        env= env';
                        current_proc_opt= parent_proc_opt; |>
                end
              end
          | Stack_cons _ _ _ ->
              error "Core_reduction ==> Stack_cons"
        end
    
    | (CTX, (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr')))) ->
        (* {A}v -> v   (in empty context) *)
        (* reduction: REMOVE-ANNOT *)
        Step_tau2 "CTX, Eannot(value)" Core_run.TSK_Misc begin
          <| th_st with arena= expr' |>
        end
    
    | (ctx, expr) ->
        let Expr e_annots expr_ = expr in
        let maybe_loc = Annot.get_loc e_annots in
        let th_st = match maybe_loc with
          | Nothing ->
              th_st
          | Just loc ->
              if Loc.is_library_location loc then
                th_st
              else
                <| th_st with current_loc= loc; |>
        end in
        let wrap_expr z = <| th_st with arena= apply_ctx ctx z |> in
        let process_action is_excluded wrap_act z =
          match step_action e_annots full_eval_pexpr' is_excluded z with
            | ACTION_REQUEST debug_str loc _request ->
                let loc' =
                  if Loc.is_library_location loc then
                    th_st.current_loc
                  else
                    loc in
                Step_action_request2 debug_str loc' current_tid (is_unseq_with_ccall ctx) begin
                  E.return match _request with
                    | CreateRequest2 pref ival ty req_addr_opt mval_opt mk_expr' ->
                        CreateRequest2 pref ival ty req_addr_opt mval_opt (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | AllocRequest2 pref ival1 ival2 mk_expr' ->
                        AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | LoadRequest2 mo ty ptrval mk_expr' ->
                        LoadRequest2 mo ty ptrval (fun aid fp mval ->
                          wrap_expr (mk_expr' aid fp mval)
                        )
                    | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                        StoreRequest2 mk ty is_locking ptrval mval (fun aid fp ->
                          wrap_expr (mk_expr' aid fp)
                        )
                    | KillRequest2 is_dynamic ptrval mk_expr' ->
                        KillRequest2 is_dynamic ptrval (fun aid ->
                          wrap_expr (mk_expr' aid)
                        )
                    | SeqRMWRequest2 _ _ _ _ ->
                        (* this is not possible *)
                        error "Core_reduction step_action returned SeqRMWRequest2"
                  end
                end
            | ACTION_EVAL debug_str eval_m ->
                Step_with_runstate2 (RSK_eval debug_str) begin
                  eval_m >>= fun act' ->
                  E.return (wrap_expr (Expr e_annots (wrap_act act')))
                end
            | ACTION_ILLTYPED str ->
                Step_error2 str
          end in
        match expr_ with
          | Epure (Pexpr _ _ (PEval _)) ->
              error ("Core_run.step_ctx ==> found a value with ctx <> CTX ==> " ^
                     Pp.stringFromCore_expr expr ^ " <--> " ^ show ctx)
          
          | Ebound (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr'))) ->
              (* bound({A}v)-> v *)
              (* reduction: REMOVE-BOUND *)
              Step_tau2 "CTX, Ebound Eannot(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Ebound (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr') ->
              (* bound(v)-> v *)
              (* reduction: REMOVE-BOUND *)
              Step_tau2 "CTX, Ebound(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Eaction (Paction p (Action loc _ (SeqRMW with_forward pe1 pe2 sym pe3))) ->
              if p = Neg then
                error "TODO(better typing) negative SeqRMW should be forbidden by the typecheck"
              else
                Step_action_request2 "SeqRMW" loc current_tid (is_unseq_with_ccall ctx) begin
                  full_eval_pexpr' pe1 >>= fun cval1 ->
                  full_eval_pexpr' pe2 >>= fun cval2 ->
                  match (cval1, cval2) with
                    | (Vctype ty, Vobject (OVpointer ptrval)) ->
                        E.fresh_excluded_id >>= fun n ->
                        E.return begin
                          SeqRMWRequest2 ty ptrval (fun mval ->
                            let th_st_tmp =
                              <| th_st with env=
                                match th_st.env with
                                  | [] ->
                                      error "Core_reduction.step_ctx, SeqRMW ==> env is empty"
                                  | x :: xs ->
                                      Map.insert sym (snd (Caux.valueFromMemValue mval)) x :: xs
                                end |> in
                            full_eval_pexpr th_st_tmp core_extern mem_st file pe3 >>= fun cval3 ->
                            match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                              | Just mval' ->
                                  E.return mval'
                              | Nothing ->
                                  error "TODO(use the error the monad) didn't match the lvalue type in SeqRMW"
                            end)
                            (fun aid fp mval mval' ->
                              let cval_e =
                                Caux.mk_value_e (snd (Caux.valueFromMemValue (if with_forward then mval' else mval))) in
                              let mk_annot_e z = Expr [] (Eannot [DA_neg n [] fp] z) in
                              (* TODO: try to factorize this with the code for negative actions *)
                              match break_at_bound_and_sseq ctx with
                                | NO_BOUND ->
                                    error "TODO: NO_BOUND (SeqRMW)"
                                | BOUND_NO_SSEQ ctx_bound ctxA ->
                                    let ctxA' = add_exclusion n ctxA in
                                    let sym = Symbol.fresh () in
                                    let expr' =
                                      Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                        ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                                     (Caux.mk_unseq_e [ mk_annot_e (Caux.mk_value_e Vunit)
                                                                      ; apply_ctx ctxA' cval_e ])
                                                     (Caux.mk_pure_e (Caux.mk_sym_pe sym)) in
                                    <| th_st with arena= apply_ctx ctx_bound expr' |>
                                | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 ->
                                    (* TODO: check *)
                                    (* Empty inner context, so no need to pull and annotate for exclusion *)
                                    <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA (Caux.mk_sseq_e sseq_pat (mk_annot_e cval_e ) sseq_e2)) |>
                                | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 ->
                                    let ctxB' = add_exclusion n ctxB in
                                    let expr' =
                                      Caux.mk_sseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                        ; sseq_pat ])
                                                     (Caux.mk_unseq_e [ mk_annot_e (Caux.mk_value_e Vunit)
                                                                      ; apply_ctx ctxB' cval_e ])
                                                     sseq_e2 in
                                    <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA expr') |>
                              end
                            )
                        end
                    | _ ->
                        error "TODO(use the error the monad) illtyped SeqRMW"
                  end
                end
              
          | Eaction (Paction p act) ->
              let Action loc _ _ = act in (* DEBUG *)
              match p with
                | Pos ->
                    process_action Nothing(*not excluded*) (fun z -> Eaction (Paction p z)) act
                | Neg ->
                    match break_at_bound_and_sseq ctx with
                      | NO_BOUND ->
                          error "TODO: NO_BOUND (Neg)"
                      | BOUND_NO_SSEQ ctx_bound ctxA ->
                          let debug_str = "Neg Action, no break ==> " ^ Loc.stringFromLocation loc in
                          Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                            E.fresh_excluded_id >>= fun n ->
                            let ctxA' = add_exclusion n ctxA in
                            let sym = Symbol.fresh () in
                            let expr' =
                              Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                             (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                              ; apply_ctx ctxA' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                             (Caux.mk_pure_e (Caux.mk_sym_pe sym)) in
                            E.return <| th_st with arena= apply_ctx ctx_bound expr' |>
                          end
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 ->
                          (* TODO: check *)
                          (* Empty inner context, so no need to pull and annotate for exclusion *)
                          Step_tau2 "Neg Action, CTX" Core_run.TSK_Misc begin
                            <| th_st with arena= apply_ctx ctx_bound
                                                   (apply_ctx ctxA (Caux.mk_sseq_e sseq_pat (Expr [] (Eaction (Paction Pos act))) sseq_e2)) |>
                          end
                          
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 ->
                          let debug_str = "Neg Action, with break" ^ Loc.stringFromLocation loc in
                          Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                            E.fresh_excluded_id >>= fun n ->
                            let ctxB' = add_exclusion n ctxB in
                            let expr' =
                              Caux.mk_sseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                ; sseq_pat ])
                                             (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                              ; apply_ctx ctxB' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                             sseq_e2 in
                            E.return <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA expr') |>
                          end
                    end
              end
          | Eexcluded n act ->
              process_action (Just n)(*is excluded*) (fun z -> Eexcluded n z) act
          
          | Eccall call_annots _ pe pes ->
              (* Step_with_runstate2 (RSK_eval "Eccall") begin *)
              Step_ccall2 current_tid begin
                full_eval_pexpr' pe >>= function
                  | Vloaded (LVspecified (OVpointer pv)) ->
                      E.mapM full_eval_pexpr' pes >>= fun cvals ->
                      let case_funptrval = function
                        | Nothing ->
                            E.undef th_st.current_loc [Undefined.UB_CERB003_invalid_function_pointer]
                        | Just psym ->
                            SEU.runEU (
                              Exception.bind (Core_run.call_proc core_extern file psym cvals)
                                EU.return
                            ) >>= fun (proc_env, expr) ->
                            E.return <| th_st with
                              arena= expr;
                              stack= Stack_cons2 th_st.current_proc_opt ctx th_st.stack;
                              exec_loc= push_exec_loc psym th_st.current_loc th_st.exec_loc;
                              env= proc_env :: th_st.env;
                              current_proc_opt= Just psym;
                            |>
                      end in
                      Mem.case_ptrval pv
                        (fun _ -> error "null function pointer")
                        case_funptrval
                      (fun _ addr ->
                        (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                        case_funptrval (Mem.case_funsym_opt mem_st pv)
                        (* match Mem.case_funsym_opt mem_st pv with
                          | Just sym ->
                              case_funptrval sym
                          | Nothing ->
                              error (show addr ^ " does not point to a function (Eccall)")
                        end *) )
                  | _ ->
                      error "TODO(use core_runM) Eccall illtyped first operand"
                end
              end
          | Eproc _ (Sym psym) pes ->
              (* reduction: PCALL *)
              Step_with_runstate2 (RSK_eval "Eproc") begin
                E.mapM full_eval_pexpr' pes >>= fun cvals ->
                 SEU.runEU (
                   Exception.bind (Core_run.call_proc core_extern file psym cvals)
                    EU.return
                 ) >>= fun (proc_env, expr) ->
                 E.return <| th_st with
                   arena= expr;
                   stack= Stack_cons2 th_st.current_proc_opt ctx th_st.stack;
                   exec_loc= push_exec_loc psym th_st.current_loc th_st.exec_loc;
                   env= proc_env :: th_st.env;
                   current_proc_opt= Just psym;
                 |>
               end
          | Eproc a (Impl iCst) pes ->
              if Core_reduction_aux.is_fs_function iCst then
                Step_fs2 current_tid th_st begin
                  E.mapM full_eval_pexpr' pes >>= fun cvals ->
                  E.return (FS_oper (Core_reduction_aux.step_fs_proc th_st iCst cvals))
                end
              else
                let wrap_proc xs = wrap_expr (Expr e_annots (Eproc a (Impl iCst) xs)) in
                process_impl_proc full_eval_pexpr' wrap_proc wrap_expr th_st iCst pes

          | Erun run_annots sym pes ->
              let current_proc =
                match th_st.current_proc_opt with
                  | Just z -> z
                  | Nothing -> error "Core_reduction ==> Erun outside of a proc"
                end in
              (* reduction: RUN *)
              Step_with_runstate2 (RSK_eval "Erun") begin
                SEU.read (fun run_st ->
                  let proc_sym = match Map.lookup current_proc core_extern with
                    | Just proc_sym -> proc_sym
                    | Nothing -> current_proc
                  end in
                  Maybe.bind (Map.lookup proc_sym run_st.labeled) (Map.lookup sym)
                ) >>= function
                  | Nothing ->
                      error ("Erun couldn't resolve label: `" ^ show sym ^
                             "' for procedure `" ^ show current_proc ^ "'")
                  | Just (sym_bTys, cont_expr) ->
                      E.foldlM (fun acc ((sym, bTy), pe) ->
                        full_eval_pexpr' pe >>= fun cval ->
                        E.return (update_env (Caux.mk_sym_pat sym bTy) cval acc)
                      ) th_st.env (List.zip sym_bTys pes) >>= fun env' ->
                      E.return <| th_st with arena= cont_expr; env= env' |>
                end
              end
          | Epar es ->
              (* This step places waiting constructs in the arena and asks the
                 driver to spawn new threads *)
              (* reduction: SPAWN *)
              Step_spawn_threads2
                (fun tids -> wrap_expr (Caux.mk_unseq_e (List.map Caux.mk_wait_e tids)))
                begin
                  List.map (fun e -> <|
                    arena= e;
                    stack= Stack_empty;
                    errno= Mem.null_ptrval Ctype.signed_int; (* TODO: allocate errno (do not store 0) *)
                    current_loc= th_st.current_loc;
                    exec_loc= ELoc_normal [];
                    env= th_st.env;
                    current_proc_opt= Nothing;
                  |>) es
                end
          | Ewait _ ->
              Step_blocked2
          | _ ->
              match one_step eval_pexpr full_eval_pexpr' th_st.env expr with
                | Nothing ->
                    error ("STUCK ==> " ^ Pp.stringFromCore_expr expr)
                | Just (TAU_WITH_RUNSTATE debug_str step_m) ->
                    Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                      step_m >>= fun (env', expr') ->
                      E.return <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                    end
                | Just (TAU debug_str env' expr') ->
                    Step_tau2 debug_str Core_run.TSK_Misc
                      <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                | Just (EVAL debug_str eval_m) ->
                    Step_with_runstate2 (RSK_eval debug_str) begin
                      eval_m >>= fun expr' ->
                      E.return (wrap_expr expr')
                    end
                | Just (ND es) ->
                    Step_nd2 (List.map wrap_expr es) 
                | Just (MEMOP memop cvals) ->
                    (* reduction: MEMOP *)
                    Step_memop_request2 th_st.current_loc memop cvals current_tid (is_unseq_with_ccall ctx) (fun cval ->
                      wrap_expr (Caux.mk_pure_e (Caux.mk_value_pe cval))
                    )
                | Just UNSEQUENCED_RACE ->
                    (* TODO: loc *)
                    Step_with_runstate2 (RSK_eval "unsequenced race") begin
                      E.undef th_st.current_loc [Undefined.UB035_unsequenced_race]
                    end
                | Just (ILLTYPED str) ->
                    Step_error2 str
              end
        end
  end) (get_ctx th_st.arena)
